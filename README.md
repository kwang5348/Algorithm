# Algorithm





###백준_2156_포도주 시식 <br>
1. 아이디어
> 세번 연속 포도주를 못마시므로
  두번 전의 기록들을 조회해 dp 방식을 적용하면 될것이다.
  
  현재까지 연속으로 마신 포도주를 인덱스화 하여 dp[n][0] dp[n][1] dp[n][2] 로 추상화 한다.
  다음에 오는 n+1의 경우
  
  0일때
  dp[n+1][0] 은 dp[n]의 dp[n][0], dp[n][1], dp[n][2] 에서 포도주를 마시지 않는 경우로 볼 수 있다. 
  따라서 dp[n][0], dp[n][1], dp[n][2] 중 최대값
  
  1일때
  dp[n+1][1] 은 n번째에서 한번도 마시지 않은 경우
                n-1 번째에서 한번도 마시지 않은 경우로 나눌 수 있다.
                따라서둘중 최대값
  
  2일때
  dp[n+1][2] 는 항상 dp[n][1] 에 n+1 의 포도주를 마시는 경우이다.
  ※ 항상 dp[n+1][2] = dp[n][1] + graph[n+1] 이 적용되기 때문에 뭔가 알고리즘에서 생략가능한것으로 예상된다.
  
2.이슈
  1일때 두가지 경우가 나오는 것을 생각하지 못해 질문게시판에서 반례를 찾았다..

###백준_1697_숨박꼭질 <br>
이슈
- 출발과 목적지가 같은경우 답이 0인 경우 문제가 있었음
